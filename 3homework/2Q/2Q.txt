[1Q. K번째 수; 새롭게 알게 된 점 & 주의할 점]
- 번째, 인덱스 번호 주의
- 2차원배열 주의[c][]
- Arrays.copyOfRange

[2Q. kakao 메뉴리뉴얼]
1. 문제 분석
코스 요리 메뉴 최소 2가지 이상의 단품메뉴 조합
손님 2개 이상 A~Z 주문, 가장 많은 조합 
orders[2~20]
orders 배열의 각 원소는 크기가 2 이상 10 이하인 문자열입니다.
알파벳 대문자로만, 중복x
course[1~10] ASC 중복x

return 문자열 형식 배열, 사전 순, 오름차순 정렬
많이 주문 메뉴 구성 여러개->모두 배열 담아 return
orders course 매개변수 return 하는 배열의 길이가 1 이상이 되도록


- 주문 다 확인 [2,3,4] 각 조합 길이 만큼, 
-> 배열(String[])은 길이 고정
-> 코스마다 조합 몇개 찾을지 모르니, 몇 개 넣을 건지 모르니,
list?  

모든 알파벳 다 찾기..?
2--> AB AC AD AE ..?
3--> ABC ACD ADE ...
4--> ABCD ACDE BCED ..?
이 조합들 키,값(정수)이거 사용해서 정수로 해놔야 개수 알 수 있나

많이 주문된 조합 수로 저장 -> 정렬(사전순) -> 결과 배열로 변환

//조합 (3C1)
order = [a,b,c] 목표 길이가 2
a b 
a c 
b c 
[ab, ac, bc]
abcd 0123
01, 02, 03, .. 중복 아닌걸 어떻게 잡지
12, 13, 
23, 아 앞 글자보다 뒤에 있는 애들만 보기
for (i=index; i<order.length; i++){
   앞글자+order[i], i+1, length
}
리턴 값 리스트 받아서 채우기
현재 조합 길이 만족 - 끝내기기
아직 아니면 글자 앞글자+order[i] 다시 돌아가는
==>중복 없이 정해진 길이만큼의 조합
글자 배열에서 정해진 수만큼 뽑아야 함
지금까지 만든 글자 저장 

//조합 어떻게 구조 잡아야할지 모르겠음 -> gpt 도움
genrateCombination()

if (max < 2) continue; 빼먹음
-->2번 이상 주문된 조합만을 고려해야 하는 문제 조건을 위반
